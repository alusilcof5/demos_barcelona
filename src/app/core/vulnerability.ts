/**
 * Sistema de càlcul de l'índex de vulnerabilitat urbana
 * Aquesta funció és auditable i reproducible
 */

import { DEFAULT_WEIGHTS } from './datasets';

export interface BarriData {
  id: string;
  nom: string;
  districte: string;
  poblacio: number;
  renda_mitjana: number;
  atur: number;
  envelliment: number;
  immigracio: number;
}

export interface BarriVulnerability extends BarriData {
  vulnerability_score: number;
  renda_normalized: number;
  atur_normalized: number;
  envelliment_normalized: number;
  immigracio_normalized: number;
  rank: number;
}

export interface Weights {
  renda: number;
  atur: number;
  envelliment: number;
  immigracio: number;
}

/**
 * Normalitza un valor entre 0 i 1
 * @param value - Valor actual
 * @param min - Valor mínim del dataset
 * @param max - Valor màxim del dataset
 * @param inverse - Si true, inverteix la normalització (per indicadors on menor és pitjor)
 */
function normalize(value: number, min: number, max: number, inverse = false): number {
  if (max === min) return 0.5;
  const normalized = (value - min) / (max - min);
  return inverse ? 1 - normalized : normalized;
}

/**
 * Calcula l'índex de vulnerabilitat per a tots els barris
 * 
 * Metodologia:
 * 1. Normalitza cada indicador entre 0 i 1
 * 2. Aplica els pesos configurats
 * 3. Suma ponderada per obtenir l'índex final
 * 
 * @param barris - Dades dels barris
 * @param weights - Pesos per a cada indicador (per defecte: DEFAULT_WEIGHTS)
 * @returns Array de barris amb índex de vulnerabilitat calculat
 */
export function calculateVulnerability(
  barris: BarriData[],
  weights: Weights = DEFAULT_WEIGHTS
): BarriVulnerability[] {
  // Validació dels pesos (han de sumar 1)
  const totalWeight = Object.values(weights).reduce((sum, w) => sum + w, 0);
  if (Math.abs(totalWeight - 1) > 0.001) {
    console.warn(`Els pesos no sumen 1 (${totalWeight}). Normalitzant...`);
    const factor = 1 / totalWeight;
    weights = {
      renda: weights.renda * factor,
      atur: weights.atur * factor,
      envelliment: weights.envelliment * factor,
      immigracio: weights.immigracio * factor
    };
  }

  // Troba valors mínims i màxims per normalitzar
  const stats = {
    renda: { min: Infinity, max: -Infinity },
    atur: { min: Infinity, max: -Infinity },
    envelliment: { min: Infinity, max: -Infinity },
    immigracio: { min: Infinity, max: -Infinity }
  };

  barris.forEach(barri => {
    stats.renda.min = Math.min(stats.renda.min, barri.renda_mitjana);
    stats.renda.max = Math.max(stats.renda.max, barri.renda_mitjana);
    stats.atur.min = Math.min(stats.atur.min, barri.atur);
    stats.atur.max = Math.max(stats.atur.max, barri.atur);
    stats.envelliment.min = Math.min(stats.envelliment.min, barri.envelliment);
    stats.envelliment.max = Math.max(stats.envelliment.max, barri.envelliment);
    stats.immigracio.min = Math.min(stats.immigracio.min, barri.immigracio);
    stats.immigracio.max = Math.max(stats.immigracio.max, barri.immigracio);
  });

  // Calcula l'índex per cada barri
  const result: BarriVulnerability[] = barris.map(barri => {
    // Normalitza cada indicador
    // Renda: menor és pitjor → inverse=true
    const renda_norm = normalize(barri.renda_mitjana, stats.renda.min, stats.renda.max, true);
    // Atur: major és pitjor → inverse=false
    const atur_norm = normalize(barri.atur, stats.atur.min, stats.atur.max, false);
    // Envelliment: major és pitjor → inverse=false
    const envelliment_norm = normalize(barri.envelliment, stats.envelliment.min, stats.envelliment.max, false);
    // Immigració: major pot indicar vulnerabilitat administrativa → inverse=false
    const immigracio_norm = normalize(barri.immigracio, stats.immigracio.min, stats.immigracio.max, false);

    // Índex de vulnerabilitat (suma ponderada)
    const vulnerability_score = 
      renda_norm * weights.renda +
      atur_norm * weights.atur +
      envelliment_norm * weights.envelliment +
      immigracio_norm * weights.immigracio;

    return {
      ...barri,
      vulnerability_score,
      renda_normalized: renda_norm,
      atur_normalized: atur_norm,
      envelliment_normalized: envelliment_norm,
      immigracio_normalized: immigracio_norm,
      rank: 0 // S'assignarà després d'ordenar
    };
  });

  // Ordena per vulnerabilitat (descendent) i assigna el rank
  result.sort((a, b) => b.vulnerability_score - a.vulnerability_score);
  result.forEach((barri, index) => {
    barri.rank = index + 1;
  });

  return result;
}

/**
 * Obté estadístiques globals de vulnerabilitat
 */
export function getVulnerabilityStats(barris: BarriVulnerability[]) {
  const scores = barris.map(b => b.vulnerability_score);
  const mean = scores.reduce((sum, s) => sum + s, 0) / scores.length;
  const variance = scores.reduce((sum, s) => sum + Math.pow(s - mean, 2), 0) / scores.length;
  const stdDev = Math.sqrt(variance);

  return {
    mean,
    stdDev,
    min: Math.min(...scores),
    max: Math.max(...scores),
    median: scores.sort((a, b) => a - b)[Math.floor(scores.length / 2)]
  };
}
