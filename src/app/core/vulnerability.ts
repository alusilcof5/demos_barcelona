/**
 * Sistema de càlcul de l'índex de vulnerabilitat urbana amb perspectiva de gènere
 * Aquesta funció és auditable i reproducible
 */

import { DEFAULT_WEIGHTS, GENDER_WEIGHTS } from './datasets';

// ✅ NUEVA INTERFAZ: Datos desagregados por sexo
export interface GenderData {
  dones: number;
  homes: number;
  total: number;
  brecha_percentual?: number; // % de diferencia
}

// ✅ ACTUALIZADA: Ahora incluye datos de género
export interface BarriData {
  id: string;
  nom: string;
  districte: string;
  
  // Población desagregada
  poblacio: number;
  poblacio_per_sexe: GenderData;
  
  // Renta desagregada por sexo
  renda_mitjana: number;
  renda_per_sexe: {
    dones: number;
    homes: number;
    brecha_percentual: number; // Calculado: (homes - dones) / homes * 100
  };
  
  // Desempleo desagregado por sexo
  atur: number;
  atur_per_sexe: {
    dones: number;
    homes: number;
    diferencia_puntos: number; // Calculado: dones - homes
  };
  
  // Indicadores sin desagregación (por ahora)
  envelliment: number;
  immigracio: number;
  
  // ✅ NUEVO: Índice de desigualdad de género
  index_desigualdad_genero?: number; // Calculado a partir de brechas
}

// ✅ ACTUALIZADA: Incluye métricas de género
export interface BarriVulnerability extends BarriData {
  vulnerability_score: number;
  
  // Normalizaciones existentes
  renda_normalized: number;
  atur_normalized: number;
  envelliment_normalized: number;
  immigracio_normalized: number;
  
  // ✅ NUEVO: Normalizaciones de género
  brecha_salarial_normalized: number;
  brecha_empleo_normalized: number;
  
  rank: number;
  rank_genero?: number; // ✅ NUEVO: Ranking específico de desigualdad de género
}

// ✅ ACTUALIZADA: Pesos con perspectiva de género
export interface Weights {
  renda: number;
  atur: number;
  envelliment: number;
  immigracio: number;
  // ✅ NUEVO: Peso para brecha de género (opcional)
  brecha_genero?: number;
}

/**
 * Normalitza un valor entre 0 i 1
 * @param value - Valor actual
 * @param min - Valor mínim del dataset
 * @param max - Valor màxim del dataset
 * @param inverse - Si true, inverteix la normalització (per indicadors on menor és pitjor)
 */
function normalize(value: number, min: number, max: number, inverse = false): number {
  if (max === min) return 0.5;
  const normalized = (value - min) / (max - min);
  return inverse ? 1 - normalized : normalized;
}

/**
 * ✅ NUEVA: Calcula el índice de desigualdad de género para un barrio
 * Combina brecha salarial y brecha de empleo
 */
function calculateGenderInequalityIndex(barri: BarriData): number {
  const brecha_salarial_norm = barri.renda_per_sexe.brecha_percentual / 100;
  const brecha_empleo_norm = Math.abs(barri.atur_per_sexe.diferencia_puntos) / 20; // Asumiendo max 20 puntos
  
  // Promedio ponderado: brecha salarial pesa más
  return (brecha_salarial_norm * 0.6 + brecha_empleo_norm * 0.4);
}

/**
 * ✅ ACTUALIZADA: Calcula l'índex de vulnerabilitat amb perspectiva de gènere
 * 
 * Metodologia:
 * 1. Normalitza cada indicador entre 0 i 1
 * 2. Aplica els pesos configurats
 * 3. Calcula índex de desigualdad de género
 * 4. Suma ponderada per obtenir l'índex final
 * 
 * @param barris - Dades dels barris amb informació de gènere
 * @param weights - Pesos per a cada indicador
 * @param includeGender - Si true, incluye brecha de género en el cálculo
 * @returns Array de barris amb índex de vulnerabilitat calculat
 */
export function calculateVulnerability(
  barris: BarriData[],
  weights: Weights = DEFAULT_WEIGHTS,
  includeGender: boolean = false
): BarriVulnerability[] {
  
  // Validació dels pesos
  const totalWeight = Object.values(weights).reduce((sum, w) => sum + w, 0);
  
  if (Math.abs(totalWeight - 1) > 0.001) {
    console.warn(`Els pesos no sumen 1 (${totalWeight}). Normalitzant...`);
    const factor = 1 / totalWeight;
    weights = {
      renda: weights.renda * factor,
      atur: weights.atur * factor,
      envelliment: weights.envelliment * factor,
      immigracio: weights.immigracio * factor,
      brecha_genero: weights.brecha_genero ? weights.brecha_genero * factor : undefined
    };
  }

  // Troba valors mínims i màxims per normalitzar
  const stats = {
    renda: { min: Infinity, max: -Infinity },
    atur: { min: Infinity, max: -Infinity },
    envelliment: { min: Infinity, max: -Infinity },
    immigracio: { min: Infinity, max: -Infinity },
    // ✅ NUEVO: Stats para brechas de género
    brecha_salarial: { min: Infinity, max: -Infinity },
    brecha_empleo: { min: Infinity, max: -Infinity }
  };

  barris.forEach(barri => {
    // Stats existentes
    stats.renda.min = Math.min(stats.renda.min, barri.renda_mitjana);
    stats.renda.max = Math.max(stats.renda.max, barri.renda_mitjana);
    stats.atur.min = Math.min(stats.atur.min, barri.atur);
    stats.atur.max = Math.max(stats.atur.max, barri.atur);
    stats.envelliment.min = Math.min(stats.envelliment.min, barri.envelliment);
    stats.envelliment.max = Math.max(stats.envelliment.max, barri.envelliment);
    stats.immigracio.min = Math.min(stats.immigracio.min, barri.immigracio);
    stats.immigracio.max = Math.max(stats.immigracio.max, barri.immigracio);
    
    // ✅ NUEVO: Stats de género
    stats.brecha_salarial.min = Math.min(stats.brecha_salarial.min, barri.renda_per_sexe.brecha_percentual);
    stats.brecha_salarial.max = Math.max(stats.brecha_salarial.max, barri.renda_per_sexe.brecha_percentual);
    stats.brecha_empleo.min = Math.min(stats.brecha_empleo.min, Math.abs(barri.atur_per_sexe.diferencia_puntos));
    stats.brecha_empleo.max = Math.max(stats.brecha_empleo.max, Math.abs(barri.atur_per_sexe.diferencia_puntos));
  });

  // Calcula l'índex per cada barri
  const result: BarriVulnerability[] = barris.map(barri => {
    // Normalitza cada indicador
    
    // Renda: menor és pitjor → inverse=true
    const renda_norm = normalize(barri.renda_mitjana, stats.renda.min, stats.renda.max, true);
    
    // Atur: major és pitjor → inverse=false
    const atur_norm = normalize(barri.atur, stats.atur.min, stats.atur.max, false);
    
    // Envelliment: major és pitjor → inverse=false
    const envelliment_norm = normalize(barri.envelliment, stats.envelliment.min, stats.envelliment.max, false);
    
    // Immigració: major pot indicar vulnerabilitat administrativa → inverse=false
    const immigracio_norm = normalize(barri.immigracio, stats.immigracio.min, stats.immigracio.max, false);
    
    // ✅ NUEVO: Normaliza brechas de género
    const brecha_salarial_norm = normalize(
      barri.renda_per_sexe.brecha_percentual, 
      stats.brecha_salarial.min, 
      stats.brecha_salarial.max, 
      false // Mayor brecha = peor
    );
    
    const brecha_empleo_norm = normalize(
      Math.abs(barri.atur_per_sexe.diferencia_puntos), 
      stats.brecha_empleo.min, 
      stats.brecha_empleo.max, 
      false // Mayor diferencia = peor
    );

    // Índex de vulnerabilitat (con o sin perspectiva de género)
    let vulnerability_score: number;
    
    if (includeGender && weights.brecha_genero) {
      // ✅ NUEVO: Cálculo con perspectiva de género
      const gender_index = (brecha_salarial_norm + brecha_empleo_norm) / 2;
      
      vulnerability_score = 
        renda_norm * weights.renda +
        atur_norm * weights.atur +
        envelliment_norm * weights.envelliment +
        immigracio_norm * weights.immigracio +
        gender_index * weights.brecha_genero;
    } else {
      // Cálculo tradicional
      vulnerability_score = 
        renda_norm * weights.renda +
        atur_norm * weights.atur +
        envelliment_norm * weights.envelliment +
        immigracio_norm * weights.immigracio;
    }

    // ✅ NUEVO: Calcula índice de desigualdad de género
    const index_desigualdad_genero = calculateGenderInequalityIndex(barri);

    return {
      ...barri,
      vulnerability_score,
      renda_normalized: renda_norm,
      atur_normalized: atur_norm,
      envelliment_normalized: envelliment_norm,
      immigracio_normalized: immigracio_norm,
      brecha_salarial_normalized: brecha_salarial_norm,
      brecha_empleo_normalized: brecha_empleo_norm,
      index_desigualdad_genero,
      rank: 0, // S'assignarà després d'ordenar
      rank_genero: 0 // S'assignarà després d'ordenar
    };
  });

  // Ordena per vulnerabilitat (descendent) i assigna el rank
  result.sort((a, b) => b.vulnerability_score - a.vulnerability_score);
  result.forEach((barri, index) => {
    barri.rank = index + 1;
  });

  // ✅ NUEVO: Ordena por desigualdad de género y asigna rank_genero
  const sortedByGender = [...result].sort((a, b) => 
    (b.index_desigualdad_genero || 0) - (a.index_desigualdad_genero || 0)
  );
  sortedByGender.forEach((barri, index) => {
    const originalBarri = result.find(b => b.id === barri.id);
    if (originalBarri) {
      originalBarri.rank_genero = index + 1;
    }
  });

  return result;
}

/**
 * Obté estadístiques globals de vulnerabilitat
 */
export function getVulnerabilityStats(barris: BarriVulnerability[]) {
  const scores = barris.map(b => b.vulnerability_score);
  const mean = scores.reduce((sum, s) => sum + s, 0) / scores.length;
  const variance = scores.reduce((sum, s) => sum + Math.pow(s - mean, 2), 0) / scores.length;
  const stdDev = Math.sqrt(variance);

  return {
    mean,
    stdDev,
    min: Math.min(...scores),
    max: Math.max(...scores),
    median: scores.sort((a, b) => a - b)[Math.floor(scores.length / 2)]
  };
}

/**
 * ✅ NUEVA: Obté estadístiques de desigualdad de género
 */
export function getGenderInequalityStats(barris: BarriVulnerability[]) {
  const brechas_salariales = barris.map(b => b.renda_per_sexe.brecha_percentual);
  const brechas_empleo = barris.map(b => Math.abs(b.atur_per_sexe.diferencia_puntos));
  const indices_genero = barris.map(b => b.index_desigualdad_genero || 0);

  return {
    brecha_salarial: {
      media: brechas_salariales.reduce((sum, b) => sum + b, 0) / brechas_salariales.length,
      min: Math.min(...brechas_salariales),
      max: Math.max(...brechas_salariales),
      barrios_mayor_brecha: barris
        .sort((a, b) => b.renda_per_sexe.brecha_percentual - a.renda_per_sexe.brecha_percentual)
        .slice(0, 5)
        .map(b => ({ nom: b.nom, brecha: b.renda_per_sexe.brecha_percentual }))
    },
    brecha_empleo: {
      media: brechas_empleo.reduce((sum, b) => sum + b, 0) / brechas_empleo.length,
      min: Math.min(...brechas_empleo),
      max: Math.max(...brechas_empleo),
      barrios_mayor_diferencia: barris
        .sort((a, b) => Math.abs(b.atur_per_sexe.diferencia_puntos) - Math.abs(a.atur_per_sexe.diferencia_puntos))
        .slice(0, 5)
        .map(b => ({ nom: b.nom, diferencia: b.atur_per_sexe.diferencia_puntos }))
    },
    indice_desigualdad: {
      media: indices_genero.reduce((sum, i) => sum + i, 0) / indices_genero.length,
      min: Math.min(...indices_genero),
      max: Math.max(...indices_genero)
    }
  };
}

/**
 * ✅ NUEVA: Clasifica barrios por nivel de desigualdad de género
 */
export function classifyGenderInequality(index: number): 'baixa' | 'mitjana' | 'alta' {
  if (index < 0.3) return 'baixa';
  if (index < 0.6) return 'mitjana';
  return 'alta';
}
/* 

import { DEFAULT_WEIGHTS } from './datasets';

export interface BarriData {
  id: string;
  nom: string;
  districte: string;
  poblacio: number;
  renda_mitjana: number;
  atur: number;
  envelliment: number;
  immigracio: number;
}

export interface BarriVulnerability extends BarriData {
  vulnerability_score: number;
  renda_normalized: number;
  atur_normalized: number;
  envelliment_normalized: number;
  immigracio_normalized: number;
  rank: number;
}

export interface Weights {
  renda: number;
  atur: number;
  envelliment: number;
  immigracio: number;
}

function normalize(value: number, min: number, max: number, inverse = false): number {
  if (max === min) return 0.5;
  const normalized = (value - min) / (max - min);
  return inverse ? 1 - normalized : normalized;
}


 * @param barris 
 * @param weights  
 * @returns

export function calculateVulnerability(
  barris: BarriData[],
  weights: Weights = DEFAULT_WEIGHTS
): BarriVulnerability[] {

  const totalWeight = Object.values(weights).reduce((sum, w) => sum + w, 0);
  if (Math.abs(totalWeight - 1) > 0.001) {
    console.warn(`Els pesos no sumen 1 (${totalWeight}). Normalitzant...`);
    const factor = 1 / totalWeight;
    weights = {
      renda: weights.renda * factor,
      atur: weights.atur * factor,
      envelliment: weights.envelliment * factor,
      immigracio: weights.immigracio * factor
    };
  }

 
  const stats = {
    renda: { min: Infinity, max: -Infinity },
    atur: { min: Infinity, max: -Infinity },
    envelliment: { min: Infinity, max: -Infinity },
    immigracio: { min: Infinity, max: -Infinity }
  };

  barris.forEach(barri => {
    stats.renda.min = Math.min(stats.renda.min, barri.renda_mitjana);
    stats.renda.max = Math.max(stats.renda.max, barri.renda_mitjana);
    stats.atur.min = Math.min(stats.atur.min, barri.atur);
    stats.atur.max = Math.max(stats.atur.max, barri.atur);
    stats.envelliment.min = Math.min(stats.envelliment.min, barri.envelliment);
    stats.envelliment.max = Math.max(stats.envelliment.max, barri.envelliment);
    stats.immigracio.min = Math.min(stats.immigracio.min, barri.immigracio);
    stats.immigracio.max = Math.max(stats.immigracio.max, barri.immigracio);
  });

 
  const result: BarriVulnerability[] = barris.map(barri => {
   
    const renda_norm = normalize(barri.renda_mitjana, stats.renda.min, stats.renda.max, true);
   
    const atur_norm = normalize(barri.atur, stats.atur.min, stats.atur.max, false);
   
    const envelliment_norm = normalize(barri.envelliment, stats.envelliment.min, stats.envelliment.max, false);
   
    const immigracio_norm = normalize(barri.immigracio, stats.immigracio.min, stats.immigracio.max, false);

    
    const vulnerability_score = 
      renda_norm * weights.renda +
      atur_norm * weights.atur +
      envelliment_norm * weights.envelliment +
      immigracio_norm * weights.immigracio;

    return {
      ...barri,
      vulnerability_score,
      renda_normalized: renda_norm,
      atur_normalized: atur_norm,
      envelliment_normalized: envelliment_norm,
      immigracio_normalized: immigracio_norm,
      rank: 0 
    };
  });


  result.sort((a, b) => b.vulnerability_score - a.vulnerability_score);
  result.forEach((barri, index) => {
    barri.rank = index + 1;
  });

  return result;
}

export function getVulnerabilityStats(barris: BarriVulnerability[]) {
  const scores = barris.map(b => b.vulnerability_score);
  const mean = scores.reduce((sum, s) => sum + s, 0) / scores.length;
  const variance = scores.reduce((sum, s) => sum + Math.pow(s - mean, 2), 0) / scores.length;
  const stdDev = Math.sqrt(variance);

  return {
    mean,
    stdDev,
    min: Math.min(...scores),
    max: Math.max(...scores),
    median: scores.sort((a, b) => a - b)[Math.floor(scores.length / 2)]
  };
}
 */